
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 24 2025 16:37:11

// Verification Directory fv/synth_wrapper 

module d_flipflop(clk, rstn, d, q);
  input clk, rstn, d;
  output q;
  wire clk, rstn, d;
  wire q;
  wire n_2;
  not g1 (n_2, rstn);
  CDN_flop q_reg(.clk (clk), .d (d), .sena (1'b1), .aclr (n_2), .apre
       (1'b0), .srl (1'b0), .srd (1'b0), .q (q));
endmodule

module register_8bit(clk, rstn, d, q);
  input clk, rstn;
  input [7:0] d;
  output [7:0] q;
  wire clk, rstn;
  wire [7:0] d;
  wire [7:0] q;
  d_flipflop bit0(clk, rstn, d[0], q[0]);
  d_flipflop bit1(clk, rstn, d[1], q[1]);
  d_flipflop bit2(clk, rstn, d[2], q[2]);
  d_flipflop bit3(clk, rstn, d[3], q[3]);
  d_flipflop bit4(clk, rstn, d[4], q[4]);
  d_flipflop bit5(clk, rstn, d[5], q[5]);
  d_flipflop bit6(clk, rstn, d[6], q[6]);
  d_flipflop bit7(clk, rstn, d[7], q[7]);
endmodule

module comparator_4bit(A, B, is_equal);
  input [3:0] A, B;
  output is_equal;
  wire [3:0] A, B;
  wire is_equal;
  wire [3:0] diff;
  wire wire3;
  xor diff_1 (diff[0], A[0], B[0]);
  xor diff_2 (diff[1], A[1], B[1]);
  xor diff_3 (diff[2], A[2], B[2]);
  xor diff_4 (diff[3], A[3], B[3]);
  or g1 (wire3, diff[0], diff[1], diff[2], diff[3]);
  not u4 (is_equal, wire3);
endmodule

module register_3bit(clk, rstn, d, q);
  input clk, rstn;
  input [2:0] d;
  output [2:0] q;
  wire clk, rstn;
  wire [2:0] d;
  wire [2:0] q;
  d_flipflop bit0(clk, rstn, d[0], q[0]);
  d_flipflop bit1(clk, rstn, d[1], q[1]);
  d_flipflop bit2(clk, rstn, d[2], q[2]);
endmodule

module mux_2x1(A, B, sel, Y);
  input A, B, sel;
  output Y;
  wire A, B, sel;
  wire Y;
  wire not_sel, select_A, select_B;
  or result (Y, select_A, select_B);
  and sel_A (select_A, A, not_sel);
  and sel_B (select_B, B, sel);
  not sel_n (not_sel, sel);
endmodule

module mux_4x1(A, B, C, D, sel, Y);
  input A, B, C, D;
  input [1:0] sel;
  output Y;
  wire A, B, C, D;
  wire [1:0] sel;
  wire Y;
  wire [1:0] L;
  mux_2x1 L1_1(A, B, sel[0], L[0]);
  mux_2x1 L1_2(C, D, sel[0], L[1]);
  mux_2x1 L2(L[0], L[1], sel[1], Y);
endmodule

module mux_8x1(A, B, C, D, E, F, G, H, sel, Y);
  input A, B, C, D, E, F, G, H;
  input [2:0] sel;
  output Y;
  wire A, B, C, D, E, F, G, H;
  wire [2:0] sel;
  wire Y;
  wire [1:0] L;
  mux_4x1 L1_1(A, B, C, D, sel[1:0], L[0]);
  mux_4x1 L1_2(E, F, G, H, sel[1:0], L[1]);
  mux_2x1 L2(L[0], L[1], sel[2], Y);
endmodule

module mux_8x1_8bit(A, B, C, D, E, F, G, H, sel, Y);
  input [7:0] A, B, C, D, E, F, G, H;
  input [2:0] sel;
  output [7:0] Y;
  wire [7:0] A, B, C, D, E, F, G, H;
  wire [2:0] sel;
  wire [7:0] Y;
  mux_8x1 u1(A[0], B[0], C[0], D[0], E[0], F[0], G[0], H[0], sel, Y[0]);
  mux_8x1 u2(A[1], B[1], C[1], D[1], E[1], F[1], G[1], H[1], sel, Y[1]);
  mux_8x1 u3(A[2], B[2], C[2], D[2], E[2], F[2], G[2], H[2], sel, Y[2]);
  mux_8x1 u4(A[3], B[3], C[3], D[3], E[3], F[3], G[3], H[3], sel, Y[3]);
  mux_8x1 u5(A[4], B[4], C[4], D[4], E[4], F[4], G[4], H[4], sel, Y[4]);
  mux_8x1 u6(A[5], B[5], C[5], D[5], E[5], F[5], G[5], H[5], sel, Y[5]);
  mux_8x1 u7(A[6], B[6], C[6], D[6], E[6], F[6], G[6], H[6], sel, Y[6]);
  mux_8x1 u8(A[7], B[7], C[7], D[7], E[7], F[7], G[7], H[7], sel, Y[7]);
endmodule

module fulladder(A, B, Ci, S, Co);
  input A, B, Ci;
  output S, Co;
  wire A, B, Ci;
  wire S, Co;
  wire w1, w2, w3;
  xor G1 (w1, A, B);
  xor G2 (S, w1, Ci);
  and G3 (w2, w1, Ci);
  and G4 (w3, A, B);
  or G5 (Co, w2, w3);
endmodule

module ripple_adder_8bit(A, B, Cin, S, Co);
  input [7:0] A, B;
  input Cin;
  output [7:0] S;
  output Co;
  wire [7:0] A, B;
  wire Cin;
  wire [7:0] S;
  wire Co;
  wire [6:0] c_wire;
  fulladder u1(A[0], B[0], Cin, S[0], c_wire[0]);
  fulladder u2(A[1], B[1], c_wire[0], S[1], c_wire[1]);
  fulladder u3(A[2], B[2], c_wire[1], S[2], c_wire[2]);
  fulladder u4(A[3], B[3], c_wire[2], S[3], c_wire[3]);
  fulladder u5(A[4], B[4], c_wire[3], S[4], c_wire[4]);
  fulladder u6(A[5], B[5], c_wire[4], S[5], c_wire[5]);
  fulladder u7(A[6], B[6], c_wire[5], S[6], c_wire[6]);
  fulladder u8(A[7], B[7], c_wire[6], S[7], Co);
endmodule

module adder_8bit(A, B, sub_mode, S, Co);
  input [7:0] A, B;
  input sub_mode;
  output [7:0] S;
  output Co;
  wire [7:0] A, B;
  wire sub_mode;
  wire [7:0] S;
  wire Co;
  wire [7:0] invert_B;
  ripple_adder_8bit u8(A, invert_B, sub_mode, S, Co);
  xor u0 (invert_B[0], B[0], sub_mode);
  xor u1 (invert_B[1], B[1], sub_mode);
  xor u2 (invert_B[2], B[2], sub_mode);
  xor u3 (invert_B[3], B[3], sub_mode);
  xor u4 (invert_B[4], B[4], sub_mode);
  xor u5 (invert_B[5], B[5], sub_mode);
  xor u6 (invert_B[6], B[6], sub_mode);
  xor u7 (invert_B[7], B[7], sub_mode);
endmodule

module and_gate_8bit(A, B, S);
  input [7:0] A, B;
  output [7:0] S;
  wire [7:0] A, B;
  wire [7:0] S;
  and bit0 (S[0], A[0], B[0]);
  and bit1 (S[1], A[1], B[1]);
  and bit2 (S[2], A[2], B[2]);
  and bit3 (S[3], A[3], B[3]);
  and bit4 (S[4], A[4], B[4]);
  and bit5 (S[5], A[5], B[5]);
  and bit6 (S[6], A[6], B[6]);
  and bit7 (S[7], A[7], B[7]);
endmodule

module or_gate_8bit(A, B, S);
  input [7:0] A, B;
  output [7:0] S;
  wire [7:0] A, B;
  wire [7:0] S;
  or bit0 (S[0], A[0], B[0]);
  or bit1 (S[1], A[1], B[1]);
  or bit2 (S[2], A[2], B[2]);
  or bit3 (S[3], A[3], B[3]);
  or bit4 (S[4], A[4], B[4]);
  or bit5 (S[5], A[5], B[5]);
  or bit6 (S[6], A[6], B[6]);
  or bit7 (S[7], A[7], B[7]);
endmodule

module xor_gate_8bit(A, B, S);
  input [7:0] A, B;
  output [7:0] S;
  wire [7:0] A, B;
  wire [7:0] S;
  xor bit0 (S[0], A[0], B[0]);
  xor bit1 (S[1], A[1], B[1]);
  xor bit2 (S[2], A[2], B[2]);
  xor bit3 (S[3], A[3], B[3]);
  xor bit4 (S[4], A[4], B[4]);
  xor bit5 (S[5], A[5], B[5]);
  xor bit6 (S[6], A[6], B[6]);
  xor bit7 (S[7], A[7], B[7]);
endmodule

module not_gate_8bit(A, S);
  input [7:0] A;
  output [7:0] S;
  wire [7:0] A;
  wire [7:0] S;
  not bit0 (S[0], A[0]);
  not bit1 (S[1], A[1]);
  not bit2 (S[2], A[2]);
  not bit3 (S[3], A[3]);
  not bit4 (S[4], A[4]);
  not bit5 (S[5], A[5]);
  not bit6 (S[6], A[6]);
  not bit7 (S[7], A[7]);
endmodule

module reverse_8bit(In, Out);
  input [7:0] In;
  output [7:0] Out;
  wire [7:0] In;
  wire [7:0] Out;
  assign Out[0] = In[7];
  assign Out[1] = In[6];
  assign Out[2] = In[5];
  assign Out[3] = In[4];
  assign Out[4] = In[3];
  assign Out[5] = In[2];
  assign Out[6] = In[1];
  assign Out[7] = In[0];
endmodule

module mux_4x1_8bit(A, B, C, D, sel, Y);
  input [7:0] A, B, C, D;
  input [1:0] sel;
  output [7:0] Y;
  wire [7:0] A, B, C, D;
  wire [1:0] sel;
  wire [7:0] Y;
  mux_4x1 u1(A[0], B[0], C[0], D[0], sel, Y[0]);
  mux_4x1 u2(A[1], B[1], C[1], D[1], sel, Y[1]);
  mux_4x1 u3(A[2], B[2], C[2], D[2], sel, Y[2]);
  mux_4x1 u4(A[3], B[3], C[3], D[3], sel, Y[3]);
  mux_4x1 u5(A[4], B[4], C[4], D[4], sel, Y[4]);
  mux_4x1 u6(A[5], B[5], C[5], D[5], sel, Y[5]);
  mux_4x1 u7(A[6], B[6], C[6], D[6], sel, Y[6]);
  mux_4x1 u8(A[7], B[7], C[7], D[7], sel, Y[7]);
endmodule

module mux_2x1_8bit(A, B, sel, Y);
  input [7:0] A, B;
  input sel;
  output [7:0] Y;
  wire [7:0] A, B;
  wire sel;
  wire [7:0] Y;
  mux_2x1 u1(A[0], B[0], sel, Y[0]);
  mux_2x1 u2(A[1], B[1], sel, Y[1]);
  mux_2x1 u3(A[2], B[2], sel, Y[2]);
  mux_2x1 u4(A[3], B[3], sel, Y[3]);
  mux_2x1 u5(A[4], B[4], sel, Y[4]);
  mux_2x1 u6(A[5], B[5], sel, Y[5]);
  mux_2x1 u7(A[6], B[6], sel, Y[6]);
  mux_2x1 u8(A[7], B[7], sel, Y[7]);
endmodule

module shift_right_1_8bit(In, Out);
  input [7:0] In;
  output [7:0] Out;
  wire [7:0] In;
  wire [7:0] Out;
  assign Out[0] = In[1];
  assign Out[1] = In[2];
  assign Out[2] = In[3];
  assign Out[3] = In[4];
  assign Out[4] = In[5];
  assign Out[5] = In[6];
  assign Out[6] = In[7];
  assign Out[7] = 1'b0;
endmodule

module shift_right_2_8bit(In, Out);
  input [7:0] In;
  output [7:0] Out;
  wire [7:0] In;
  wire [7:0] Out;
  assign Out[0] = In[2];
  assign Out[1] = In[3];
  assign Out[2] = In[4];
  assign Out[3] = In[5];
  assign Out[4] = In[6];
  assign Out[5] = In[7];
  assign Out[6] = 1'b0;
  assign Out[7] = 1'b0;
endmodule

module shift_right_4_8bit(In, Out);
  input [7:0] In;
  output [7:0] Out;
  wire [7:0] In;
  wire [7:0] Out;
  assign Out[0] = In[4];
  assign Out[1] = In[5];
  assign Out[2] = In[6];
  assign Out[3] = In[7];
  assign Out[4] = 1'b0;
  assign Out[5] = 1'b0;
  assign Out[6] = 1'b0;
  assign Out[7] = 1'b0;
endmodule

module shifter_8bit(A, B, mode, S);
  input [7:0] A, B;
  input mode;
  output [7:0] S;
  wire [7:0] A, B;
  wire mode;
  wire [7:0] S;
  wire [1:0] sel_output;
  wire [7:0] A_reversed;
  wire [7:0] stage4;
  wire [7:0] stage4_reversed;
  wire [7:0] stage1;
  wire [7:0] stage1_shifted;
  wire [7:0] stage2;
  wire [7:0] stage2_shifted;
  wire [7:0] stage3;
  wire [7:0] stage3_shifted;
  wire n_41;
  reverse_8bit u1(A, A_reversed);
  mux_4x1_8bit u10(.A (stage4), .B (stage4_reversed), .C (8'b00000000),
       .D (8'b00000000), .sel ({sel_output[1], mode}), .Y (S));
  mux_2x1_8bit u2(A, A_reversed, mode, stage1);
  shift_right_1_8bit u3({stage1[7:1], 1'b0}, stage1_shifted);
  mux_2x1_8bit u4(stage1, stage1_shifted, B[0], stage2);
  shift_right_2_8bit u5({stage2[7:2], 2'b00}, stage2_shifted);
  mux_2x1_8bit u6(stage2, stage2_shifted, B[1], stage3);
  shift_right_4_8bit u7({stage3[7:4], 4'b0000}, stage3_shifted);
  mux_2x1_8bit u8(stage3, stage3_shifted, B[2], stage4);
  reverse_8bit u9(stage4, stage4_reversed);
  or g1 (n_41, B[3], B[4]);
  or g2 (sel_output[1], B[5], B[6], B[7], n_41);
endmodule

module alu_8bit(i_clk, i_rstn, i_a, i_b, i_op_sel, o_result, o_carry);
  input i_clk, i_rstn;
  input [7:0] i_a, i_b;
  input [2:0] i_op_sel;
  output [7:0] o_result;
  output o_carry;
  wire i_clk, i_rstn;
  wire [7:0] i_a, i_b;
  wire [2:0] i_op_sel;
  wire [7:0] o_result;
  wire o_carry;
  wire [7:0] result_d;
  wire [7:0] A;
  wire [7:0] B;
  wire [2:0] op_sel;
  wire [7:0] result_add;
  wire [7:0] result_and;
  wire [7:0] result_or;
  wire [7:0] result_xor;
  wire [7:0] result_not;
  wire [7:0] result_shift;
  wire carry_d, cout_adder, is_logical_op, shift_mode, sub_mode;
  d_flipflop Cout_buff(i_clk, i_rstn, carry_d, o_carry);
  register_8bit S_buff(i_clk, i_rstn, result_d, o_result);
  comparator_4bit check_for_LEFT_SHIFT(.A ({1'b0, i_op_sel}), .B
       (4'b0111), .is_equal (shift_mode));
  comparator_4bit check_for_SUB(.A ({1'b0, i_op_sel}), .B (4'b0001),
       .is_equal (sub_mode));
  register_8bit fetch_A(i_clk, i_rstn, i_a, A);
  register_8bit fetch_B(i_clk, i_rstn, i_b, B);
  register_3bit fetch_op(i_clk, i_rstn, i_op_sel, op_sel);
  mux_2x1 select_cout(.A (cout_adder), .B (1'b0), .sel (is_logical_op),
       .Y (carry_d));
  mux_8x1_8bit select_result(.A (result_add), .B (result_add), .C
       (result_and), .D (result_or), .E (result_xor), .F (result_not),
       .G (result_shift), .H (result_shift), .sel (op_sel), .Y
       (result_d));
  adder_8bit u01(A, B, sub_mode, result_add, cout_adder);
  and_gate_8bit u2(A, B, result_and);
  or_gate_8bit u3(A, B, result_or);
  xor_gate_8bit u4(A, B, result_xor);
  not_gate_8bit u5(A, result_not);
  shifter_8bit u67(A, B, shift_mode, result_shift);
  or u8 (is_logical_op, i_op_sel[2], i_op_sel[1]);
endmodule

module synth_wrapper(clk, rst_n, A, B, op_sel, result, carry);
  input clk, rst_n;
  input [7:0] A, B;
  input [2:0] op_sel;
  output [7:0] result;
  output carry;
  wire clk, rst_n;
  wire [7:0] A, B;
  wire [2:0] op_sel;
  wire [7:0] result;
  wire carry;
  wire [7:0] A_reg;
  wire [7:0] B_reg;
  wire [2:0] op_sel_reg;
  wire carry_reg_84, n_29, \result_reg[0]_60 , \result_reg[1]_61 ,
       \result_reg[2]_62 , \result_reg[3]_63 , \result_reg[4]_64 ,
       \result_reg[5]_65 ;
  wire \result_reg[6]_66 , \result_reg[7]_67 ;
  alu_8bit dutty(.i_clk (clk), .i_rstn (rst_n), .i_a (A_reg), .i_b
       (B_reg), .i_op_sel (op_sel_reg), .o_result ({\result_reg[7]_67 ,
       \result_reg[6]_66 , \result_reg[5]_65 , \result_reg[4]_64 ,
       \result_reg[3]_63 , \result_reg[2]_62 , \result_reg[1]_61 ,
       \result_reg[0]_60 }), .o_carry (carry_reg_84));
  CDN_flop \A_reg_reg[0] (.clk (clk), .d (A[0]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[0]));
  CDN_flop \A_reg_reg[1] (.clk (clk), .d (A[1]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[1]));
  CDN_flop \A_reg_reg[2] (.clk (clk), .d (A[2]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[2]));
  CDN_flop \A_reg_reg[3] (.clk (clk), .d (A[3]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[3]));
  CDN_flop \A_reg_reg[4] (.clk (clk), .d (A[4]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[4]));
  CDN_flop \A_reg_reg[5] (.clk (clk), .d (A[5]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[5]));
  CDN_flop \A_reg_reg[6] (.clk (clk), .d (A[6]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[6]));
  CDN_flop \A_reg_reg[7] (.clk (clk), .d (A[7]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (A_reg[7]));
  CDN_flop \B_reg_reg[0] (.clk (clk), .d (B[0]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[0]));
  CDN_flop \B_reg_reg[1] (.clk (clk), .d (B[1]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[1]));
  CDN_flop \B_reg_reg[2] (.clk (clk), .d (B[2]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[2]));
  CDN_flop \B_reg_reg[3] (.clk (clk), .d (B[3]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[3]));
  CDN_flop \B_reg_reg[4] (.clk (clk), .d (B[4]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[4]));
  CDN_flop \B_reg_reg[5] (.clk (clk), .d (B[5]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[5]));
  CDN_flop \B_reg_reg[6] (.clk (clk), .d (B[6]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[6]));
  CDN_flop \B_reg_reg[7] (.clk (clk), .d (B[7]), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (B_reg[7]));
  CDN_flop carry_reg(.clk (clk), .d (carry_reg_84), .sena (1'b1), .aclr
       (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (carry));
  not g1 (n_29, rst_n);
  CDN_flop \op_sel_reg_reg[0] (.clk (clk), .d (op_sel[0]), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (op_sel_reg[0]));
  CDN_flop \op_sel_reg_reg[1] (.clk (clk), .d (op_sel[1]), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (op_sel_reg[1]));
  CDN_flop \op_sel_reg_reg[2] (.clk (clk), .d (op_sel[2]), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (op_sel_reg[2]));
  CDN_flop \result_reg[0] (.clk (clk), .d (\result_reg[0]_60 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[0]));
  CDN_flop \result_reg[1] (.clk (clk), .d (\result_reg[1]_61 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[1]));
  CDN_flop \result_reg[2] (.clk (clk), .d (\result_reg[2]_62 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[2]));
  CDN_flop \result_reg[3] (.clk (clk), .d (\result_reg[3]_63 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[3]));
  CDN_flop \result_reg[4] (.clk (clk), .d (\result_reg[4]_64 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[4]));
  CDN_flop \result_reg[5] (.clk (clk), .d (\result_reg[5]_65 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[5]));
  CDN_flop \result_reg[6] (.clk (clk), .d (\result_reg[6]_66 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[6]));
  CDN_flop \result_reg[7] (.clk (clk), .d (\result_reg[7]_67 ), .sena
       (1'b1), .aclr (n_29), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[7]));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
